# design-pattern

# Design Patterns

## 1. Creational Patterns
Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

### Subtypes:
- **Abstract Factory**  
  Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

- **Builder**  
  Allows the construction of a complex object step by step. It separates the construction of an object from its representation.

- **Factory Method**  
  Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.

- **Prototype**  
  Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.

- **Singleton**  
  Ensures that a class has only one instance, and provides a global point of access to that instance.

---

## 2. Structural Patterns
Structural patterns deal with object composition, creating relationships between objects to form larger structures.

### Subtypes:
- **Adapter**  
  Allows incompatible interfaces to work together. It wraps an existing class and provides a new interface.

- **Bridge**  
  Decouples an abstraction from its implementation so that both can vary independently.

- **Composite**  
  Composes objects into tree-like structures to represent part-whole hierarchies.

- **Decorator**  
  Attaches additional responsibilities to an object dynamically. It provides a flexible alternative to subclassing for extending functionality.

- **Facade**  
  Provides a simplified interface to a complex subsystem, making it easier to use.

- **Flyweight**  
  Reduces the number of objects created by sharing common objects, saving memory and improving performance.

- **Proxy**  
  Provides a surrogate or placeholder object to control access to another object.

---

## 3. Behavioral Patterns
Behavioral patterns deal with object interaction and responsibility delegation among objects.

### Subtypes:
- **Chain of Responsibility**  
  Passes a request along a chain of handlers, allowing multiple handlers to process the request.

- **Command**  
  Encapsulates a request as an object, allowing for parameterization of clients with queues, requests, and operations.

- **Interpreter**  
  Defines a representation for a grammar and provides an interpreter to process sentences in the grammar.

- **Iterator**  
  Provides a way to access elements of a collection sequentially without exposing its underlying structure.

- **Mediator**  
  Defines an object that encapsulates how a set of objects interact, promoting loose coupling between objects.

- **Memento**  
  Captures and externalizes an object's internal state without violating encapsulation, allowing it to be restored later.

- **Observer**  
  Defines a one-to-many dependency between objects, so that when one object changes state, all dependent objects are notified and updated.

- **State**  
  Allows an object to alter its behavior when its internal state changes, appearing as if the object has changed its class.

- **Strategy**  
  Defines a family of algorithms, encapsulates each one, and makes them interchangeable. It allows the algorithm to be selected at runtime.

- **Template Method**  
  Defines the skeleton of an algorithm, deferring some steps to subclasses. It lets subclasses redefine certain steps of the algorithm.

- **Visitor**  
  Represents an operation to be performed on the elements of an object structure, allowing new operations to be added without changing the classes of the elements.

---

## Design Pattern Structure




